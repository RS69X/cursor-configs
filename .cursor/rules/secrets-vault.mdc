# Règles Gestion des Secrets et Vault

**Scope**: `**/k8s/**`, `**/kubernetes/**`, `**/manifests/**`, `**/*.yaml`, `**/*.yml`, `**/secrets/**`, `**/vault/**`

## Persona

Tu es un expert DevOps et Kubernetes, spécialisé en GitOps avec ArgoCD, gestion de clusters, et déploiements continus.

## Contexte Technique

- Kubernetes (version selon le cluster)
- **HashiCorp Vault** : Système centralisé de gestion des secrets pour toutes les applications
- **External Secrets Operator (ESO)** : Synchronisation des secrets depuis Vault vers Kubernetes
- **Sealed Secrets** : Chiffrement des secrets dans Git (optionnel)
- Manifests Kubernetes (Deployments, Services, ConfigMaps, Secrets, Ingress, etc.)

## Contraintes Strictes - Secrets Management

- ✅ Ne jamais commiter de secrets en clair dans Git.
- ✅ Utiliser des secrets externes (External Secrets Operator, Sealed Secrets, etc.).
- ✅ Utiliser des annotations ArgoCD pour la gestion des secrets (`argocd.argoproj.io/sync-wave`).
- ✅ Chiffrer les secrets au repos avec des outils appropriés.
- ✅ Roter les secrets régulièrement.
- ✅ Limiter l'accès aux secrets avec RBAC.
- ✅ Ne jamais logger ou exposer des secrets dans les logs.

## Secrets Management - Vue d'ensemble

**Stratégies recommandées** :

1. **Vault + External Secrets Operator** : Pour les secrets managés centralement
2. **Sealed Secrets** : Pour chiffrer les secrets dans Git (alternative)
3. **Kubernetes Secrets natifs** : Uniquement pour les secrets non-critiques et temporaires

## HashiCorp Vault - Intégration Kubernetes

**Contexte** : HashiCorp Vault est utilisé comme système centralisé de gestion des secrets pour toutes les applications Kubernetes.

**Fonctionnalités Vault utilisées** :

- ✅ **KV Secrets Engine** : Stockage des secrets clé-valeur
- ✅ **Kubernetes Auth Method** : Authentification Kubernetes native
- ✅ **Vault Agent Injector** : Injection automatique de secrets dans les pods
- ✅ **Dynamic Secrets** : Génération de secrets à la demande (DB credentials, etc.)
- ✅ **Encryption as a Service** : Chiffrement/déchiffrement de données

## External Secrets Operator avec Vault

**External Secrets Operator (ESO)** : Utiliser ESO pour synchroniser les secrets depuis Vault vers Kubernetes.

### SecretStore pour Vault

**Exemple SecretStore** :

```yaml
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: vault-backend
  namespace: production
spec:
  provider:
    vault:
      server: https://vault.example.com:8200
      path: secret
      version: v2
      auth:
        kubernetes:
          mountPath: kubernetes
          role: my-app-role
          serviceAccountRef:
            name: external-secrets-sa
            namespace: external-secrets-system
```

### ExternalSecret avec Vault

**Exemple ExternalSecret complet** :

```yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: db-secret-vault
  namespace: production
  annotations:
    argocd.argoproj.io/sync-wave: '0' # Synchroniser avant les Deployments
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: vault-backend
    kind: SecretStore
  target:
    name: db-secret
    creationPolicy: Owner
    template:
      type: Opaque
  data:
    - secretKey: database-url
      remoteRef:
        key: secret/data/production/db
        property: url
    - secretKey: database-password
      remoteRef:
        key: secret/data/production/db
        property: password
    - secretKey: database-username
      remoteRef:
        key: secret/data/production/db
        property: username
```

**Bonnes pratiques ExternalSecret** :

- Utiliser `refreshInterval` approprié selon la criticité des secrets
- Configurer `creationPolicy: Owner` pour permettre la suppression automatique
- Utiliser des annotations ArgoCD pour contrôler l'ordre de synchronisation
- Documenter les chemins Vault utilisés

## Vault Agent Injector

**Vault Agent Injector** : Injection automatique de secrets dans les pods sans External Secrets Operator.

**Exemple Deployment avec Vault Agent Injector** :

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
  namespace: production
  annotations:
    vault.hashicorp.com/agent-inject: 'true'
    vault.hashicorp.com/role: 'my-app-role'
    vault.hashicorp.com/agent-inject-secret-db: 'secret/data/production/db'
    vault.hashicorp.com/agent-inject-template-db: |
      {{- with secret "secret/data/production/db" }}
      export DB_URL="{{ .Data.data.url }}"
      export DB_USER="{{ .Data.data.username }}"
      export DB_PASSWORD="{{ .Data.data.password }}"
      {{- end }}
spec:
  template:
    metadata:
      annotations:
        vault.hashicorp.com/agent-inject: 'true'
        vault.hashicorp.com/role: 'my-app-role'
        vault.hashicorp.com/agent-inject-secret-db: 'secret/data/production/db'
        vault.hashicorp.com/agent-inject-template-db: |
          {{- with secret "secret/data/production/db" }}
          export DB_URL="{{ .Data.data.url }}"
          export DB_USER="{{ .Data.data.username }}"
          export DB_PASSWORD="{{ .Data.data.password }}"
          {{- end }}
    spec:
      serviceAccountName: my-app-sa
      containers:
        - name: app
          image: my-app:latest
          # Les secrets sont injectés dans /vault/secrets/ par Vault Agent
```

**Annotations Vault Agent Injector** :

- `vault.hashicorp.com/agent-inject: 'true'` : Activer l'injection
- `vault.hashicorp.com/role: 'my-app-role'` : Rôle Vault à utiliser
- `vault.hashicorp.com/agent-inject-secret-<name>: '<path>'` : Chemin du secret dans Vault
- `vault.hashicorp.com/agent-inject-template-<name>: '<template>'` : Template pour formater le secret

## Kubernetes Auth Method

**Configuration Kubernetes Auth Method dans Vault** :

```bash
# Configuration dans Vault (via CLI ou API)
# Créer un rôle Kubernetes pour l'application
vault write auth/kubernetes/role/my-app-role \
bound_service_account_names=my-app-sa \
bound_service_account_namespaces=production \
policies=my-app-policy \
ttl=1h
```

**Paramètres importants** :

- `bound_service_account_names` : ServiceAccount Kubernetes autorisé
- `bound_service_account_namespaces` : Namespaces autorisés
- `policies` : Policies Vault à appliquer
- `ttl` : Durée de vie du token (recommandé : 1h)

## Vault Policies

**Exemple Vault Policy** :

```hcl
# Policy Vault : my-app-policy
path "secret/data/production/db" {
  capabilities = ["read"]
}

path "secret/data/production/*" {
  capabilities = ["read"]
}

# Dynamic secrets pour bases de données
path "database/creds/my-app" {
  capabilities = ["read"]
}
```

**Bonnes pratiques Vault Policies** :

- Utiliser le principe du moindre privilège
- Séparer les chemins par environnement (`secret/data/dev/*`, `secret/data/production/*`)
- Limiter les capabilities au strict nécessaire (`read`, `list`, etc.)
- Documenter toutes les policies créées

## Dynamic Secrets avec Vault

**Dynamic Secrets** : Génération de secrets à la demande pour les bases de données.

**Exemple ExternalSecret avec Dynamic Secrets** :

```yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: db-dynamic-secret
  namespace: production
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: vault-backend
    kind: SecretStore
  target:
    name: db-secret
  data:
    - secretKey: username
      remoteRef:
        key: database/creds/my-app
        property: username
    - secretKey: password
      remoteRef:
        key: database/creds/my-app
        property: password
```

**Avantages des Dynamic Secrets** :

- Rotation automatique des credentials
- Réduction de la surface d'attaque
- Traçabilité complète des accès
- Pas de stockage permanent des credentials

## Best Practices Vault

- ✅ **Séparation par environnement** : Utiliser des chemins différents (`secret/data/dev/*`, `secret/data/production/*`)
- ✅ **Politiques minimales** : Accorder uniquement les permissions nécessaires (principle of least privilege)
- ✅ **Rotation des secrets** : Configurer des politiques de rotation automatique
- ✅ **Audit logging** : Activer les logs d'audit Vault pour tracer l'accès aux secrets
- ✅ **Backup régulier** : Sauvegarder régulièrement les données Vault (snapshots)
- ✅ **HA Configuration** : Configurer Vault en haute disponibilité pour la production
- ✅ **TLS** : Utiliser TLS pour toutes les communications avec Vault
- ✅ **Token TTL** : Configurer des TTL appropriés pour les tokens (pas trop longs)

## Sécurité Vault

- ✅ Ne jamais exposer Vault publiquement sans authentification appropriée
- ✅ Utiliser des ServiceAccounts dédiés pour chaque application
- ✅ Limiter les namespaces autorisés dans les rôles Kubernetes
- ✅ Utiliser des policies Vault restrictives
- ✅ Surveiller les accès aux secrets via les logs d'audit
- ✅ Chiffrer les données au repos dans Vault
- ✅ Utiliser des secrets rotatifs pour les credentials critiques
- ✅ Configurer des alertes pour les accès suspects

## Sealed Secrets

**Sealed Secrets** : Alternative pour chiffrer les secrets dans Git de manière sécurisée.

**Exemple SealedSecret** :

```yaml
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: db-secret
  namespace: production
spec:
  encryptedData:
    password: AgBy3i4OJSWK+PiTySYZZA9rO43cGDEQAx...
    username: AgBx...
  template:
    metadata:
      name: db-secret
      namespace: production
    type: Opaque
```

**Utilisation de Sealed Secrets** :

1. Créer un Secret Kubernetes normal
2. Utiliser `kubeseal` pour le chiffrer : `kubeseal < secret.yaml > sealed-secret.yaml`
3. Commiter le SealedSecret dans Git
4. Le Sealed Secrets Controller déchiffre automatiquement dans le cluster

**Quand utiliser Sealed Secrets** :

- Pour des secrets simples qui doivent être versionnés dans Git
- Quand Vault n'est pas disponible
- Pour des secrets non-critiques

**Quand utiliser Vault** :

- Pour des secrets critiques nécessitant une rotation
- Pour des secrets partagés entre plusieurs applications
- Pour des secrets dynamiques (DB credentials, etc.)

## Organisation des Secrets par Environnement

**Structure recommandée dans Vault** :

```
secret/
├── data/
│   ├── dev/
│   │   ├── db
│   │   ├── redis
│   │   └── api-keys
│   ├── test/
│   │   ├── db
│   │   ├── redis
│   │   └── api-keys
│   └── production/
│       ├── db
│       ├── redis
│       └── api-keys
```

**Conventions de nommage** :

- Chemins Vault : `secret/data/<environment>/<service-name>`
- ExternalSecrets : `<service-name>-secret-<env>.yaml`
- Secrets Kubernetes : `<service-name>-secret` (généré automatiquement)

## Intégration avec ArgoCD

**Sync Waves pour les Secrets** :

```yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: db-secret
  namespace: production
  annotations:
    argocd.argoproj.io/sync-wave: '0' # Synchroniser avant les Deployments
spec:
  # Configuration...
```

**Bonnes pratiques avec ArgoCD** :

- Utiliser des sync waves pour garantir l'ordre de déploiement
- Configurer des projets ArgoCD avec restrictions pour les secrets
- Ne jamais utiliser `automated` sync pour les ExternalSecrets en production
- Documenter les dépendances entre secrets et applications

## ClusterSecretStore

- ✅ Utiliser `ClusterSecretStore` pour partager un SecretStore entre plusieurs namespaces.
- ✅ Préférer `SecretStore` au niveau namespace pour l'isolation.
- ✅ Utiliser `ClusterSecretStore` uniquement pour les backends partagés.

**Exemple ClusterSecretStore** :

```yaml
apiVersion: external-secrets.io/v1beta1
kind: ClusterSecretStore
metadata:
  name: vault-cluster-backend
spec:
  provider:
    vault:
      server: https://vault.example.com:8200
      path: secret
      version: v2
      auth:
        kubernetes:
          mountPath: kubernetes
          role: cluster-role
          serviceAccountRef:
            name: external-secrets-sa
            namespace: external-secrets-system
```

**Quand utiliser ClusterSecretStore vs SecretStore** :

- **ClusterSecretStore** : Pour un backend Vault partagé entre tous les namespaces
- **SecretStore** : Pour un backend Vault spécifique à un namespace (isolation)

## ExternalSecret avec Transformation

- ✅ Utiliser des transformations pour formater les secrets avant injection.
- ✅ Utiliser des templates pour générer des fichiers de configuration.

**Exemple ExternalSecret avec transformation** :

```yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: db-secret-transformed
  namespace: production
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: vault-backend
    kind: SecretStore
  target:
    name: db-secret
    creationPolicy: Owner
    template:
      type: Opaque
      data:
        database.conf: |
          host={{ .database-url | toString }}
          user={{ .database-username | toString }}
          password={{ .database-password | toString }}
  data:
    - secretKey: database-url
      remoteRef:
        key: secret/data/production/db
        property: url
    - secretKey: database-username
      remoteRef:
        key: secret/data/production/db
        property: username
    - secretKey: database-password
      remoteRef:
        key: secret/data/production/db
        property: password
```

**Exemple ExternalSecret avec plusieurs sources** :

```yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: multi-source-secret
  namespace: production
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: vault-backend
    kind: SecretStore
  target:
    name: app-secret
  data:
    - secretKey: db-url
      remoteRef:
        key: secret/data/production/db
        property: url
    - secretKey: redis-url
      remoteRef:
        key: secret/data/production/redis
        property: url
    - secretKey: api-key
      remoteRef:
        key: secret/data/production/api-keys
        property: my-api-key
```

## Vault Transit Engine

- ✅ Utiliser le Transit Engine pour chiffrer/déchiffrer des données.
- ✅ Utiliser Transit pour le chiffrement de données sensibles dans les applications.

**Configuration Transit Engine** :

```bash
# Activer le Transit Engine
vault secrets enable transit

# Créer une clé de chiffrement
vault write -f transit/keys/my-app-key

# Chiffrer des données
vault write transit/encrypt/my-app-key plaintext=$(echo "sensitive-data" | base64)

# Déchiffrer des données
vault write transit/decrypt/my-app-key ciphertext="vault:v1:..."
```

**Exemple Policy pour Transit** :

```hcl
# Policy Vault pour Transit Engine
path "transit/encrypt/my-app-key" {
  capabilities = ["update"]
}

path "transit/decrypt/my-app-key" {
  capabilities = ["update"]
}
```

**Utilisation dans les applications** :

- Les applications peuvent utiliser Transit pour chiffrer/déchiffrer des données
- Transit permet la rotation automatique des clés
- Transit supporte le chiffrement de champs spécifiques

## Vault PKI Engine

- ✅ Utiliser le PKI Engine pour générer des certificats TLS.
- ✅ Intégrer PKI avec cert-manager pour la gestion automatique des certificats.

**Configuration PKI Engine** :

```bash
# Activer le PKI Engine
vault secrets enable pki

# Configurer la CA root
vault write pki/root/generate/internal \
  common_name="example.com" \
  ttl=87600h

# Configurer les URLs
vault write pki/config/urls \
  issuing_certificates="https://vault.example.com/v1/pki/ca" \
  crl_distribution_points="https://vault.example.com/v1/pki/crl"
```

**Exemple Policy pour PKI** :

```hcl
# Policy Vault pour PKI Engine
path "pki/issue/my-app" {
  capabilities = ["create", "update"]
}
```

**Intégration avec cert-manager** :

- Utiliser cert-manager avec Vault PKI pour générer des certificats automatiquement
- Configurer un ClusterIssuer pour Vault PKI
- Les certificats sont générés et renouvelés automatiquement

## Vault AppRole Auth Method

- ✅ Utiliser AppRole comme alternative à Kubernetes Auth.
- ✅ AppRole est utile pour les applications non-Kubernetes ou les CI/CD.

**Configuration AppRole** :

```bash
# Activer AppRole
vault auth enable approle

# Créer un rôle
vault write auth/approle/role/my-app-role \
  token_policies="my-app-policy" \
  token_ttl=1h \
  token_max_ttl=4h

# Obtenir le role-id
vault read auth/approle/role/my-app-role/role-id

# Générer un secret-id
vault write -f auth/approle/role/my-app-role/secret-id
```

**Utilisation avec External Secrets Operator** :

```yaml
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: vault-backend-approle
  namespace: production
spec:
  provider:
    vault:
      server: https://vault.example.com:8200
      path: secret
      version: v2
      auth:
        approle:
          roleId: <role-id>
          secretRef:
            name: vault-approle-secret
            key: secretId
```

## Rotation des Secrets

- ✅ Configurer des politiques de rotation automatique pour les secrets critiques.
- ✅ Utiliser Dynamic Secrets pour la rotation automatique des credentials DB.
- ✅ Documenter les procédures de rotation manuelle.

**Rotation avec Dynamic Secrets** :

- Les Dynamic Secrets sont automatiquement rotés par Vault
- Configurer des TTL appropriés pour les credentials
- Surveiller les rotations via les logs d'audit

**Rotation manuelle** :

```bash
# Mettre à jour un secret dans Vault
vault kv put secret/data/production/db \
  url="postgresql://new-host:5432/mydb" \
  username="new-user" \
  password="new-password"

# External Secrets Operator synchronisera automatiquement
```

**Bonnes pratiques Rotation** :

- Automatiser la rotation des secrets critiques
- Tester les procédures de rotation dans un environnement de test
- Documenter les fenêtres de maintenance pour la rotation
- Surveiller les échecs de rotation

## Monitoring et Alerting

- ✅ Surveiller l'état de Vault et des External Secrets.
- ✅ Configurer des alertes pour les échecs de synchronisation.
- ✅ Surveiller les accès aux secrets via les logs d'audit.

**Métriques à surveiller** :

- État de santé de Vault (health checks)
- Échecs de synchronisation des External Secrets
- Accès aux secrets (via audit logs)
- Expiration des tokens Vault
- Utilisation des secrets rotatifs

**Exemple ServiceMonitor pour Vault** :

```yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: vault
  namespace: vault
spec:
  selector:
    matchLabels:
      app: vault
  endpoints:
    - port: http
      path: /v1/sys/metrics
      interval: 30s
```

**Alertes recommandées** :

- Vault inaccessible
- Échec de synchronisation External Secret
- Accès suspect aux secrets
- Token Vault expiré
- Échec de rotation de secret

## Troubleshooting

- ✅ Diagnostiquer les problèmes courants avec Vault et External Secrets.
- ✅ Vérifier les logs et les statuts des ressources.

**Problèmes courants External Secrets** :

```bash
# Vérifier le statut d'un ExternalSecret
kubectl describe externalsecret db-secret -n production

# Vérifier les logs d'External Secrets Operator
kubectl logs -n external-secrets-system deployment/external-secrets

# Vérifier le statut du SecretStore
kubectl describe secretstore vault-backend -n production
```

**Problèmes courants Vault** :

```bash
# Vérifier l'état de santé de Vault
vault status

# Vérifier les logs Vault
kubectl logs -n vault deployment/vault

# Tester l'authentification Kubernetes
vault write auth/kubernetes/login \
  role=my-app-role \
  jwt=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
```

**Commandes de diagnostic** :

- `kubectl get externalsecret` : Lister les External Secrets
- `kubectl describe externalsecret <name>` : Détails d'un External Secret
- `vault kv get secret/data/production/db` : Vérifier un secret dans Vault
- `vault token lookup` : Vérifier les permissions du token

## Vault CLI - Commandes Utiles

- ✅ Utiliser la CLI Vault pour gérer les secrets et les policies.

**Commandes Vault essentielles** :

```bash
# Authentification
export VAULT_ADDR='https://vault.example.com:8200'
vault auth -method=kubernetes role=my-app-role

# Lire un secret
vault kv get secret/data/production/db

# Écrire un secret
vault kv put secret/data/production/db \
  url="postgresql://host:5432/db" \
  username="user" \
  password="pass"

# Lister les secrets
vault kv list secret/data/production/

# Créer une policy
vault policy write my-app-policy policy.hcl

# Lister les policies
vault policy list

# Vérifier les permissions
vault token capabilities secret/data/production/db
```

**Bonnes pratiques CLI** :

- Utiliser des tokens avec TTL appropriés
- Ne jamais exposer les tokens dans les logs
- Utiliser des variables d'environnement pour VAULT_ADDR
- Documenter les commandes fréquemment utilisées

## Backup et Restore Vault

- ✅ Sauvegarder régulièrement les données Vault.
- ✅ Tester les procédures de restauration.
- ✅ Documenter les procédures de backup.

**Backup Vault** :

```bash
# Snapshot de Vault
vault operator raft snapshot save vault.snapshot

# Backup avec API
curl \
  --header "X-Vault-Token: $VAULT_TOKEN" \
  https://vault.example.com/v1/sys/storage/raft/snapshot \
  -o vault.snapshot
```

**Restore Vault** :

```bash
# Restaurer depuis un snapshot
vault operator raft snapshot restore vault.snapshot
```

**Bonnes pratiques Backup** :

- Automatiser les backups réguliers
- Stocker les backups dans un endroit sécurisé
- Tester les restaurations régulièrement
- Documenter les procédures de restauration
- Chiffrer les backups

## Vault Unseal

- ✅ Comprendre le processus de déverrouillage de Vault.
- ✅ Configurer Auto-unseal pour la production.
- ✅ Documenter les procédures d'urgence.

**Unseal manuel** :

```bash
# Déverrouiller Vault avec les clés de déverrouillage
vault operator unseal <unseal-key-1>
vault operator unseal <unseal-key-2>
vault operator unseal <unseal-key-3>
```

**Auto-unseal** :

- Configurer Auto-unseal avec AWS KMS, Azure Key Vault, ou GCP KMS
- Auto-unseal évite le besoin de déverrouillage manuel
- Essentiel pour la haute disponibilité en production

**Bonnes pratiques Unseal** :

- Utiliser Auto-unseal en production
- Stocker les clés de déverrouillage de manière sécurisée
- Documenter les procédures d'urgence
- Tester les procédures de déverrouillage

## Secret Versioning

- ✅ Utiliser le versioning des secrets dans Vault KV v2.
- ✅ Accéder aux versions précédentes si nécessaire.

**Versioning KV v2** :

```bash
# Lire une version spécifique
vault kv get -version=1 secret/data/production/db

# Lister les versions
vault kv metadata get secret/data/production/db

# Restaurer une version précédente
vault kv rollback -version=1 secret/data/production/db
```

**Bonnes pratiques Versioning** :

- Utiliser KV v2 pour le versioning automatique
- Documenter les changements de secrets importants
- Tester les restaurations de versions précédentes
- Surveiller l'utilisation du stockage (versions conservées)

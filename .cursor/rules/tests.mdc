# Règles pour les Tests

**Scope**: `**/*.test.*`, `**/*.spec.*`, `**/__tests__/**`, `**/tests/**`

## Persona
Tu es un expert en tests logiciels, spécialisé en tests unitaires, d'intégration, et TDD (Test-Driven Development).

## Contexte Technique
- Tests unitaires avec isolation complète
- Tests d'intégration pour les flux critiques
- Mocks et stubs pour les dépendances externes
- Couverture de code cible : >80% pour le code métier

## Contraintes Strictes

### Structure des Tests
- ✅ Un fichier de test par fichier source (ex: `user.test.ts` pour `user.ts`).
- ✅ Organiser les tests avec `describe()` et `it()` / `test()`.
- ✅ Nommer les tests de manière descriptive : "should do X when Y".
- ❌ Ne jamais tester l'implémentation, seulement le comportement.

### Isolation et Mocks
- ✅ Isoler chaque test (pas de dépendances entre tests).
- ✅ Utiliser des mocks pour les dépendances externes (API, DB, fichiers).
- ✅ Réinitialiser les mocks entre les tests.

### Assertions
- ✅ Utiliser des assertions spécifiques et descriptives.
- ✅ Tester les cas limites (edge cases) et les erreurs.
- ❌ Ne jamais utiliser d'assertions génériques (`expect(true)`).

## Exemples

#### ✅ Bon : Test isolé avec mocks
```typescript
// user.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { createUser } from './user';
import { db } from './db';

// Mock de la dépendance externe
vi.mock('./db');

describe('createUser', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should create a user with valid data', async () => {
    const mockUser = { id: '1', email: 'test@example.com', age: 25 };
    vi.mocked(db.createUser).mockResolvedValue(mockUser);

    const result = await createUser({
      email: 'test@example.com',
      age: 25,
    });

    expect(result).toEqual(mockUser);
    expect(db.createUser).toHaveBeenCalledWith({
      email: 'test@example.com',
      age: 25,
    });
  });

  it('should throw error when email is invalid', async () => {
    await expect(
      createUser({ email: 'invalid-email', age: 25 })
    ).rejects.toThrow('Invalid email');
  });
});
```

#### ❌ Mauvais : Test non isolé, pas de mocks
```typescript
// ❌ Mauvais : Dépendance réelle à la DB
describe('createUser', () => {
  it('should create a user', async () => {
    const result = await createUser({
      email: 'test@example.com',
      age: 25,
    });
    expect(result).toBeTruthy(); // Assertion trop générique
  });
});
```

#### ✅ Bon : Test Python avec pytest et mocks
```python
# test_user.py
import pytest
from unittest.mock import AsyncMock, patch
from app.services.user import create_user

@pytest.mark.asyncio
async def test_create_user_with_valid_data():
    mock_user = {"id": "1", "email": "test@example.com", "age": 25}
    
    with patch('app.services.user.db') as mock_db:
        mock_db.create_user = AsyncMock(return_value=mock_user)
        
        result = await create_user({
            "email": "test@example.com",
            "age": 25,
        })
        
        assert result == mock_user
        mock_db.create_user.assert_called_once()
```

### Tests d'Intégration
- Utiliser une base de données de test isolée.
- Nettoyer les données après chaque test.
- Tester les flux complets (end-to-end) pour les scénarios critiques.

### Coverage
- Viser >80% de couverture pour le code métier.
- Ne pas tester le code généré automatiquement.
- Utiliser des outils comme `vitest --coverage` ou `pytest-cov`.

### Test-Driven Development (TDD)
- Écrire les tests avant le code pour les nouvelles fonctionnalités.
- Faire échouer le test d'abord (Red).
- Implémenter le minimum pour faire passer le test (Green).
- Refactoriser si nécessaire (Refactor).

# Règles Python avec Type Hints

**Scope**: `**/*.py`

## Persona
Tu es un expert Python, spécialisé en typage moderne, asyncio, et bonnes pratiques Python 3.10+.

## Contexte Technique
- Python 3.10+ avec type hints partout
- Pydantic v2 pour les modèles de données
- Pattern RORO (Receive Object, Return Object) pour la scalabilité
- Gestion d'erreurs explicite avec logging

## Contraintes Strictes

### Type Hints
- ✅ Toujours ajouter des type hints pour les paramètres et valeurs de retour.
- ✅ Utiliser `from __future__ import annotations` pour les annotations différées.
- ✅ Utiliser `typing.Protocol` pour les interfaces structurelles.
- ❌ Ne jamais utiliser `Any` sauf si absolument nécessaire (avec commentaire).

### Pydantic v2
- Utiliser `model_validate()` au lieu de `parse_obj()` (déprécié).
- Utiliser `model_dump()` au lieu de `dict()`.
- Préférer `Field()` pour les validations complexes.

### Pattern RORO
- Les fonctions doivent recevoir et retourner des objets typés (dicts TypedDict ou Pydantic models).
- Cela facilite l'évolution des signatures sans casser les appels existants.

### Gestion d'Erreurs
- ❌ **JAMAIS** utiliser `except: pass` ou `except Exception: pass`.
- ✅ Toujours logger les erreurs avec le contexte complet.
- ✅ Utiliser des exceptions personnalisées pour les erreurs métier.

### Asyncio
- Utiliser `async`/`await` pour les opérations I/O.
- Utiliser `asyncio.gather()` pour les opérations parallèles.
- Toujours gérer les timeouts avec `asyncio.wait_for()`.

## Exemples

#### ✅ Bon : Type hints + Pydantic v2
```python
from __future__ import annotations
from typing import TypedDict
from pydantic import BaseModel, Field, field_validator

class UserCreate(BaseModel):
    email: str = Field(..., description="User email address")
    age: int = Field(..., ge=0, le=150)
    
    @field_validator('email')
    @classmethod
    def validate_email(cls, v: str) -> str:
        if '@' not in v:
            raise ValueError('Invalid email format')
        return v.lower()

def create_user(data: dict[str, object]) -> UserCreate:
    # Validation avec Pydantic v2
    return UserCreate.model_validate(data)
```

#### ❌ Mauvais : Pas de type hints + gestion d'erreur silencieuse
```python
def create_user(data):
    try:
        # Code sans validation
        return {"email": data["email"], "age": data["age"]}
    except:
        pass  # ❌ Erreur ignorée
```

#### ✅ Bon : Pattern RORO avec TypedDict
```python
from typing import TypedDict

class UserInput(TypedDict):
    email: str
    age: int

class UserOutput(TypedDict):
    id: str
    email: str
    age: int

def process_user(input_data: UserInput) -> UserOutput:
    # Traitement...
    return {
        "id": "123",
        "email": input_data["email"],
        "age": input_data["age"],
    }
```

#### ✅ Bon : Gestion d'erreurs avec logging
```python
import logging
from typing import Optional

logger = logging.getLogger(__name__)

class UserNotFoundError(Exception):
    pass

def get_user(user_id: str) -> Optional[User]:
    try:
        return db.get_user(user_id)
    except DatabaseError as e:
        logger.error(
            "Failed to fetch user",
            extra={"user_id": user_id, "error": str(e)},
            exc_info=True
        )
        raise UserNotFoundError(f"User {user_id} not found") from e
```

### Formatage et Style
- Suivre PEP 8 avec `black` pour le formatage.
- Utiliser `ruff` pour le linting.
- Maximum 88 caractères par ligne (configuration black).
